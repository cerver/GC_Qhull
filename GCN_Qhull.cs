using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.ComponentModel;


using Bentley.GenerativeComponents;
using Bentley.GenerativeComponents.Features;
using Bentley.GenerativeComponents.Features.Specific;
using Bentley.GenerativeComponents.GCScript;
using Bentley.GenerativeComponents.GCScript.GCTypes;
using Bentley.GenerativeComponents.GCScript.NameScopes;
using Bentley.GenerativeComponents.GCScript.ReflectedNativeTypeSupport;
using Bentley.GenerativeComponents.GeneralPurpose;
using Bentley.GenerativeComponents.MicroStation;
using Bentley.GenerativeComponents.Nodes;
using Bentley.Geometry;
using Bentley.Interop.MicroStationDGN;


/*
 this is an experimental node that is the new Node version of the Qhull Feature. it does not work in its current state and is set to not complie.
 * need to find way to make geometry in the new Node Class 
 */

namespace Bentley.GenerativeComponents.Nodes.Specific
{

    public enum GeometryOutput { None, Curves, Polygons, All };
    //[GCNamespace("Bentley.GC", true)]
    public class Qhull : Node// , IControlPanelShowableNode
    {
        public const string QhullPath = System.Reflection.Assembly.GetExecutingAssembly().Location +  @"\QHull\qhull.exe";
        
        //input
        public const string NameOfPointSet              = "PointSet";
        public const string NameOfGeometryType          = "GeometryType";
        public const string NameOfCustomString          = "CustomString";
        //output
        public const string NameOfOutPoints             = "QhullPoints";
        public const string NameOfPolygon               = "QhullPolygons";
        public const string NameOfCurve                 = "QhullCurves";
        //NodeTechnique
        public const string techDefault                 = "Voronoi2D";
        public const string techVor3d                   = "Voronoi3D";
        public const string techDel2d                   = "Delaunay2D";
        public const string techDel3d                   = "Delaunay3D";
        public const string techConvex2d                = "ConvexHull2D";
        public const string techConvex3d                = "ConvexHull3D";
        public const string techCustom                  = "Custom";

     
        static private readonly NodeGCType s_gcTypeOfAllInstances = (NodeGCType) GCTypeTools.GetGCType(typeof(Qhull));

        static public NodeGCType GCTypeOfAllInstances
        {
            get { return s_gcTypeOfAllInstances; }
        }

        static private void GCType_AddAdditionalMembersTo(GCType gcType, NativeNamespaceTranslator namespaceTranslator)
        {

            {
                NodeTechnique method = gcType.AddDefaultNodeTechnique(techDefault, Vor2d);

                //inputs
                method.AddArgumentDefinition(NameOfPointSet, typeof(IPoint[]), "", "Set of input points to evaluate with QHull");
                method.AddArgumentDefinition(NameOfPointSet, typeof(GeometryOutput), "", "Set the type of geomtry to output");
                //outputs
                method.AddArgumentDefinition(NameOfOutPoints, typeof(IPoint[]), "null", "The points generated by QHull", NodePortRole.TechniqueOutputOnly);
                method.AddArgumentDefinition(NameOfPolygon, typeof(Polygon[]), "null", "Polygon representation of the 2D Voronoi", NodePortRole.TechniqueOutputOnly);
                method.AddArgumentDefinition(NameOfPolygon, typeof(BSplineCurve[]), "null", "Curve representation of the 2D Voronoi", NodePortRole.TechniqueOutputOnly);
            }
            {
                NodeTechnique method = gcType.AddDefaultNodeTechnique(techVor3d, Vor3d);

                //inputs
                method.AddArgumentDefinition(NameOfPointSet, typeof(IPoint[]), "", "Set of input points to evaluate with QHull");
                method.AddArgumentDefinition(NameOfPointSet, typeof(GeometryOutput), "", "Set the type of geomtry to output");
                //outputs
                method.AddArgumentDefinition(NameOfOutPoints, typeof(IPoint[]), "null", "The points generated by QHull", NodePortRole.TechniqueOutputOnly);
                method.AddArgumentDefinition(NameOfPolygon, typeof(Polygon[][]), "null", "Polygon representation of the 3D Voronoi. Each array contains the faces of each 3d cell", NodePortRole.TechniqueOutputOnly);
            }   method.AddArgumentDefinition(NameOfCurve, typeof(BSplineCurve[][]), "null", "Curve representation of the 3D Voronoi", NodePortRole.TechniqueOutputOnly);
            {
                NodeTechnique method = gcType.AddDefaultNodeTechnique(techConvex2d, Convex2d);

                //inputs
                method.AddArgumentDefinition(NameOfPointSet, typeof(IPoint[]), "", "Set of input points to evaluate with QHull");
                method.AddArgumentDefinition(NameOfPointSet, typeof(GeometryOutput), "", "Set the type of geomtry to output");
                //outputs
                method.AddArgumentDefinition(NameOfOutPoints, typeof(IPoint[]), "null", "The points generated by QHull", NodePortRole.TechniqueOutputOnly);
                method.AddArgumentDefinition(NameOfPolygon, typeof(Polygon), "null", "Polygon representation of the 2D convex hull", NodePortRole.TechniqueOutputOnly);
            }   method.AddArgumentDefinition(NameOfCurve, typeof(BSplineCurve), "null", "Curve representation of the 2D convex hull", NodePortRole.TechniqueOutputOnly);
            {
                NodeTechnique method = gcType.AddDefaultNodeTechnique(techConvex3d, Convex3d);

                //inputs
                method.AddArgumentDefinition(NameOfPointSet, typeof(IPoint[]), "", "Set of input points to evaluate with QHull");
                method.AddArgumentDefinition(NameOfPointSet, typeof(GeometryOutput), "", "Set the type of geomtry to output");
                //outputs
                method.AddArgumentDefinition(NameOfOutPoints, typeof(IPoint[]), "null", "The points generated by QHull", NodePortRole.TechniqueOutputOnly);
                method.AddArgumentDefinition(NameOfPolygon, typeof(Polygon[]), "null", "Polygon representation of the 3D convex hull", NodePortRole.TechniqueOutputOnly);
            }   method.AddArgumentDefinition(NameOfCurve, typeof(BSplineCurve[]), "null", "Curve representation of the 3D convex hull", NodePortRole.TechniqueOutputOnly);
        }
        
        static private NodeTechniqueResult Vor2d(Node node, IGCEnvironment gcEnvironment, NameCatalog nameCatalog, NodeScopeUpdateReason updateReason)
        {
            Qhull qhl = (Qhull)node;
            return NodeTechniqueResult.Success;
        }

        static private NodeTechniqueResult Vor3d(Node node, IGCEnvironment gcEnvironment, NameCatalog nameCatalog, NodeScopeUpdateReason updateReason)
        {
            Qhull qhl = (Qhull)node;

            string[] outputStrSp;
            DPoint3d[][] qhullDpoints;
            IPoint[][] qhullPoints =  SendToQhull(qhl.PointSet, "v Qj", 3, true, false, out outputStrSp, out qhullDpoints);

                string[] tempOut = null;
                DPoint3d[][] tempDp = null;

                Polygon[][] tempPg = new Polygon[qhullPoints.Length][];
                int ct = 0;

                for (int i = 0; i < qhullPoints.Length; i++)
                {

                    rcHelper.runQhull.Run(qhullDpoints[i], "c", 3, ref tempOut);
                    if (tempOut.Length >= 3)
                    {
                        rcHelper.offParser.Parse(tempOut, 3, true, false, out tempDp);

                        //cereate polygon
                        tempPg[ct] = new Polygon[tempDp.Length];
                        for (int j = 0; j < tempDp.Length; ++j)
                        {
                            //PolygonalGeometry.CreatePolygon(gcEnvironment, qhl.na, null, true, true, null, qhullPoints );
                            //ShapeElement poly = Shap
                        }
                        ct++;
                    }


                }


                return NodeTechniqueResult.Success;
        }
        static private NodeTechniqueResult Convex2d(Node node, IGCEnvironment gcEnvironment, NameCatalog nameCatalog, NodeScopeUpdateReason updateReason)
        {
            Qhull qhl = (Qhull)node;
            return NodeTechniqueResult.Success;
        }
        static private NodeTechniqueResult Convex3d(Node node, IGCEnvironment gcEnvironment, NameCatalog nameCatalog, NodeScopeUpdateReason updateReason)
        {
            Qhull qhl = (Qhull)node;
            return NodeTechniqueResult.Success;
        }
        static private NodeTechniqueResult Del2d(Node node, IGCEnvironment gcEnvironment, NameCatalog nameCatalog, NodeScopeUpdateReason updateReason)
        {
            Qhull qhl = (Qhull)node;
            return NodeTechniqueResult.Success;
        }
        static private NodeTechniqueResult Del3d(Node node, IGCEnvironment gcEnvironment, NameCatalog nameCatalog, NodeScopeUpdateReason updateReason)
        {
            Qhull qhl = (Qhull)node;
            return NodeTechniqueResult.Success;
        }
        static private NodeTechniqueResult Custom (Node node, IGCEnvironment gcEnvironment, NameCatalog nameCatalog, NodeScopeUpdateReason updateReason)
        {
            Qhull qhl = (Qhull)node;
            return NodeTechniqueResult.Success;
        }
  
        // ======================================== end of static members ========================================

        public IPoint[] PointSet
        {
            get { return ActiveNodeState.PointSetProp.GetNativeValue<IPoint[]>(); }
            set { ActiveNodeState.PointSetProp.SetNativeValueAndInputExpression(value); }
        }

        public GeometryOutput GeometryType
        {
            get { return ActiveNodeState.GeomOutProp.GetNativeValue<GeometryOutput>(); }
            set { ActiveNodeState.GeomOutProp.SetNativeValueAndInputExpression(value); }
        }

        public IPoint[] outPoints
        {
            get { return ActiveNodeState.OutPointsProp.GetNativeValue<IPoint[]>(); }
            set { ActiveNodeState.OutPointsProp.SetNativeValueAndInputExpression(value); }
        }
        public IPoint[][] outPoints
        {
            get { return ActiveNodeState.OutPointsProp.GetNativeValue<IPoint[][]>(); }
            set { ActiveNodeState.OutPointsProp.SetNativeValueAndInputExpression(value); }
        }
        public ICurve outCurves
        {
            get { return ActiveNodeState.OutCurveProp.GetNativeValue<ICurve>(); }
            set { ActiveNodeState.OutCurveProp.SetNativeValueAndInputExpression(value); }
        }
        public ICurve[] outCurves
        {
            get { return ActiveNodeState.OutCurveProp.GetNativeValue<ICurve[]>(); }
            set { ActiveNodeState.OutCurveProp.SetNativeValueAndInputExpression(value); }
        }
        public ICurve[][] outCurves
        {
            get { return ActiveNodeState.OutCurveProp.GetNativeValue<ICurve[][]>(); }
            set { ActiveNodeState.OutCurveProp.SetNativeValueAndInputExpression(value); }
        }
        public Polygon outCurves
        {
            get { return ActiveNodeState.OutPolygonProp.GetNativeValue<Polygon>(); }
            set { ActiveNodeState.OutPolygonProp.SetNativeValueAndInputExpression(value); }
        }
        public Polygon[] outCurves
        {
            get { return ActiveNodeState.OutPolygonProp.GetNativeValue<Polygon[]>(); }
            set { ActiveNodeState.OutPolygonProp.SetNativeValueAndInputExpression(value); }
        }
        public Polygon[][] outCurves
        {
            get { return ActiveNodeState.OutPolygonProp.GetNativeValue<Polygon[][]>(); }
            set { ActiveNodeState.OutPolygonProp.SetNativeValueAndInputExpression(value); }
        }

        //*********************
        private static IPoint[][] SendToQhull( IPoint[] pointSet, String qmode, int Dimension, bool filterInf, bool isD3d, out string[] QhullOutput, out DPoint3d[][] PointsAsDP3d)
        {
            // run qhull
            string[] outputStrSp = null;
            rcHelper.runQhull.Run(Translation.ConvertToDPoint3dArray(pointSet) , qmode, Dimension, ref outputStrSp);
            QhullOutput = outputStrSp;

            DPoint3d[][] dpoints;
            //parse the output
            rcHelper.offParser.Parse(outputStrSp, Dimension, filterInf, isD3d, out dpoints);

            IPoint[][] p = new IPoint[dpoints.Length][];
            Point3d[] p3d = new Point3d[dpoints.Length];
            for (int i = 0; i < dpoints.Length; i++)
            {
                for (int j = 0; j < dpoints[i].Length; j++)
                {
                    p3d[i] = new Point3d();
                    p3d[i].X = dpoints[i][j].X;
                    p3d[i].Y = dpoints[i][j].Y;
                    p3d[i].Z = dpoints[i][j].Z;

                }
                p[i] = Point.ConvertFromDPoint3dList(p3d);

            }

            return p;

        }

            
        //*********************
     
        public Qhull
        (
            NodeGCType gcType,
            INodeScope parentNodeScope,
            INameScope parentNameScope,
            string initialBasicName
        )
            : base(gcType, parentNodeScope, parentNameScope, initialBasicName)
        {
            Debug.Assert(gcType == s_gcTypeOfAllInstances);

        }
        /*
        public override Type TypeOfCustomViewContent(NodeCustomViewContext context)  // INode.TypeOfCustomViewBody
        {
            
            switch (context)
            {
                case NodeCustomViewContext.GraphNode: return typeof(qqq);  
                case NodeCustomViewContext.ControlPanel: return typeof(qqq);  
            }
            Debug.Assert(false);
             
            return null;

   
        }
        */

        protected override Node.NodeState GetInitialNodeState(NodeScopeState parentNodeScopeState, string parentNodeInitialBasicName, NodeTechniqueDetermination nameOfInitiallyActiveTechnique)
        {
            return new Qhull.NodeState(this, parentNodeScopeState, parentNodeInitialBasicName, nameOfInitiallyActiveTechnique);
        }
         

        internal new NodeState ActiveNodeState
        {
            get { return (NodeState) base.ActiveNodeState; }
        }


        public new class NodeState: Node.NodeState
        {
            internal readonly NodeProperty PointSetProp;
            internal readonly NodeProperty GeomOutProp;
            internal readonly NodeProperty CustomStringProp;
            internal readonly NodeProperty OutPointsProp;
            internal readonly NodeProperty OutPolygonProp;
            internal readonly NodeProperty OutCurveProp;

            internal protected NodeState(Qhull parentNode, NodeScopeState parentNodeScopeState, string parentNodeInitialBasicName, NodeTechniqueDetermination initialActiveTechniqueDetermination)
                : base(parentNode, parentNodeScopeState, parentNodeInitialBasicName, initialActiveTechniqueDetermination)
            {
                // This constructor is called when the parent node is created.
                // To create each property, we call AddProperty (rather to GetProperty).

                PointSetProp = AddProperty(NameOfPointSet);
                GeomOutProp = AddProperty(NameOfGeometryType);
                CustomStringProp = AddProperty(NameOfCustomString);
                OutPointsProp = AddProperty(NameOfOutPoints);
                OutPolygonProp = AddProperty(NameOfPolygon);
                OutCurveProp = AddProperty(NameOfCurve);

            }

            protected NodeState(NodeState source, NodeScopeState parentNodeScopeState): base(source, parentNodeScopeState)  // For cloning.
            {
                // This constructor is called whenever the node state is copied.
                // To copy each property, we call GetProperty (rather than AddProperty).

                PointSetProp = GetProperty(NameOfPointSet);
                GeomOutProp = GetProperty(NameOfGeometryType);
                CustomStringProp = GetProperty(NameOfCustomString);
                OutPointsProp = GetProperty(NameOfOutPoints);
                OutPolygonProp = GetProperty(NameOfPolygon);
                OutCurveProp = GetProperty(NameOfCurve);
            }

            protected new Qhull ParentNode
            {
                get { return (Qhull)base.ParentNode; }
            }

            public override Node.NodeState Clone(NodeScopeState newParentNodeScopeState)
            {
                return new NodeState(this, newParentNodeScopeState);
            }

            
        }
    }
}
